## Snippets from SnipMate, taken from
## https://github.com/scrooloose/snipmate-snippets.git

snippet p "php" w
<?php
$0
endsnippet

snippet fw_log "Description" w
function fw_log() {
	$args = func_get_args();
	add_action( 'shutdown',
		function () use ( $args ) {?>
			<script>
				<?php array_map( function ( $value ) {
					?>console.log( <?= json_encode( $value ) ?> );
				<?php }, $args) ?>
			</script>
		<?php } );
}

fw_log($0);
endsnippet

snippet ifndef "" !b
if ( ! function_exists( '${1:function}' ) ) {
	function $1($2) {
		$0
	}
}
endsnippet

snippet wpajax "Description" !b
add_action( 'wp_ajax_my_action', 'my_action_callback' );

function my_action_callback() {
	global $wpdb; // this is how you get access to the database

	$whatever = intval( $_POST['whatever'] );

	$whatever += 10;

        echo $whatever;

	wp_die(); // this is required to terminate immediately and return a proper response
}
endsnippet

# Use this every day
# Relies on the fact that psysh is installed in my home dir
# and on the fact that my current user is named andreiglingeanu, should refactor
# this
snippet debug "Description" !b
require "/Users/andreiglingeanu/.composer/vendor/bin/psysh";
\Psy\Shell::debug(get_defined_vars());
endsnippet

snippet debugt "Description" !b
require "/Users/andreiglingeanu/.composer/vendor/bin/psysh";
\Psy\Shell::debug(get_defined_vars(), $this);
endsnippet

snippet ifndeffw "framework" w
if (! defined('FW')) { die('Forbidden'); }
endsnippet

snippet ifndefabs "framework" w
if (! defined('ABSPATH')) { die('Forbidden'); }
endsnippet

snippet php "php" w
<?php
$0
?>
endsnippet

snippet phpi "php" w
<?php $0 ?>
endsnippet

snippet e "echo" w
echo($1)$0
endsnippet

snippet vd "var_dump" w
var_dump($1)$0
endsnippet

snippet printf "printf .. (printf)"
printf("${1:%s}\n"${1/([^%]|%%)*(%.)?.*/(?2:, :\);)/}$2${1/([^%]|%%)*(%.)?.*/(?2:\);)/}
endsnippet

snippet pe "echo" w
<?= $1 ?>$0
endsnippet

snippet echo "echo" w
echo $0
endsnippet

snippet prr "print_r" w
print_r($1)$0
endsnippet

snippet def "def"
define('${1}'${2});${3}
endsnippet

snippet each "each html" w
<?php foreach(${1} as ${2}): ?>
	$0
<?php endforeach; ?>
endsnippet

snippet eachk "each html" w
<? foreach(${1} as ${2} => ${3}): ?>
	$0
<? endforeach; ?>
endsnippet

snippet foreachk "foreachk"
foreach ($${1:variable} as $${2:key} => $${3:value}){
	${4:// code...}
}
endsnippet

snippet foreach "foreach"
foreach ($${1:variable} as $${2:key}){
	${3:// code...}
}
endsnippet

snippet if "if"
if (${1:/* condition */})
{
	${2:// code...}
}
endsnippet

snippet ifh "if html" w
<?php if ($1) { ?>
	$0
<?php } ?>
endsnippet

snippet elseh "else html" w
<?php else: ?>
endsnippet

snippet inc "inc"
include '${1:file}';${2}
endsnippet

snippet log "log"
error_log(var_export(${1}, true));${2}
endsnippet

snippet post "post"
$_POST['${1}']${2}
endsnippet

snippet req1 "req1"
require_once '${1:file}';${2}
endsnippet

snippet t "t"
$${1:retVal} = (${2:condition}) ? ${3:a} : ${4:b};${5}
endsnippet

snippet var "var"
var_export(${1});${2}
endsnippet

snippet pub "Public function" !b
public function ${1:name}(${2:$param})
{
    ${VISUAL}${3:return null;}
}
$0
endsnippet

snippet pro "Protected function" !b
protected function ${1:name}(${2:$param})
{
    ${VISUAL}${3:return null;}
}
$0
endsnippet

snippet pri "Private function" !b
private function ${1:name}(${2:$param})
{
    ${VISUAL}${3:return null;}
}
$0
endsnippet

snippet pubs "Public static function" !b
public static function ${1:name}(${2:$param})
{
    ${VISUAL}${3:return null;}
}
$0
endsnippet

snippet pros "Protected static function" !b
protected static function ${1:name}(${2:$param})
{
    ${VISUAL}${3:return null;}
}
$0
endsnippet

snippet pris "Private static function" !b
private static function ${1:name}(${2:$param})
{
    ${VISUAL}${3:return null;}
}
$0
endsnippet

snippet fu "Function snip" w
function ${1:name}(${2:$param})
{
	${VISUAL}${3:return null;}
}
endsnippet

snippet fore "Foreach loop"
foreach ($${1:variable} as $${3:value}){
    ${VISUAL}${4}
}
$0
endsnippet

snippet new "New class instance" !b
$$1 = new $1($2);
$0
endsnippet

snippet class "Class declaration template" !b
/**
 * Class ${1:`!p snip.rv=snip.fn.capitalize().split('.')[0]`}
 */
class $2
{
    public function ${3:__construct}(${4:$options})
    {
        ${4:// code}
    }
}
$0
endsnippet

snippet pr "Dumb debug helper in HTML"
echo '<pre>' . var_export($1, 1) . '</pre>';$0
endsnippet

snippet pucase "PHPUnit / Test case" b
<?php

use PHPUnit\Framework\TestCase;

class ${1} extends TestCase
{
	${VISUAL}${0}
}
endsnippet


snippet putest "PHPUnit / Test method" b
public function test${1}()
{
	${VISUAL}${0}
}
endsnippet

snippet pua "PHPUnit / Assert" b
\$this->assert${1}(${2});
endsnippet

snippet putrue "PHPUnit / Assert true" b
\$this->assertTrue(${1});
endsnippet

snippet pufalse "PHPUnit / Assert false" b
\$this->assertFalse(${1});
endsnippet

snippet punull "PHPUnit / Assert null" b
\$this->assertNull(${1});
endsnippet

snippet pusame "PHPUnit / Assert same" b
\$this->assertSame(${1}, ${2});
endsnippet

snippet puequals "PHPUnit / Assert equals" b
\$this->assertEquals(${1}, ${2});
endsnippet

snippet pucount "PHPUnit / Assert count" b
\$this->assertCount(${1}, ${2});
endsnippet

snippet pucontains "PHPUnit / Assert contains" b
\$this->assertContains(${1}, ${2});
endsnippet

snippet puinstance "PHPUnit / Assert instance of" b
\$this->assertInstanceOf(${1}::class, ${2});
endsnippet

snippet puincomplete "PHPUnit / Mark incomplete" b
\$this->markTestIncomplete(${1:'This test has not been implemented yet.'});
endsnippet

snippet puskip "PHPUnit / Mark skipped" b
\$this->markTestSkipped(${1:'This test has been skipped.'});
endsnippet

snippet pufail "PHPUnit / Fail" b
\$this->fail(${1});
endsnippet

snippet puexception "PHPUnit / Expect exception" b
\$this->expectException(${1}::class);
\$this->expectExceptionMessage('${2}');
endsnippet

snippet pustub "PHPUnit / Create stub" b
\$${2:`!p snip.rv = sniphpets.lcfirst(t[1])`} = \$this->createMock(${1}::class);
\$$2
	->method('${3}')
	->will(\$this->returnValue(${4}));
endsnippet

snippet pufake "PHPUnit / Create fake" b
\$${2:`!p snip.rv = sniphpets.lcfirst(t[1])`} = \$this->createMock(${1}::class);
\$$2
	->method('${3}')
	->will(\$this->returnCallback(
		function (${4}) {
			${5}
		}
	));
endsnippet

snippet pupro "PHPUnit / Prophesize" b
\$${2:`!p snip.rv = sniphpets.lcfirst(t[1])`} = \$this->prophesize(${1}::class);
endsnippet

snippet pumock "PHPUnit / Create mock" b
\$${2:`!p snip.rv = sniphpets.lcfirst(t[1])`} = \$this->createMock(${1}::class);
endsnippet

snippet pumockbuilder "PHPUnit / Mock builder" b
\$${2:`!p snip.rv = sniphpets.lcfirst(t[1])`} = \$this
	->getMockBuilder(${1}::class)
	->setMethods([${2}])
	->disableOriginalConstructor()
	->getMock();
endsnippet

snippet pumockdoc "PHPUnit / Mock Object doc"
/**
 * @var \PHPUnit_Framework_MockObject_MockObject
 */
endsnippet

snippet puexpects "PHPUnit / Expects" b
\$${1}
	->expects(\$this->${2:once}())
	->method('${3}')
endsnippet

snippet puwill "PHPUnit / Will" i
->will(\$this->${1}(${2}));
endsnippet

snippet puwillreturn "PHPUnit / Will return" i
->will(\$this->return${1:Value}(${2}));
endsnippet

snippet puwillvalue "PHPUnit / Will return value" i
->will(\$this->returnValue(${1}));
endsnippet

snippet puwillargument "PHPUnit / Will return argument" i
->will(\$this->returnArgument(${1}))
endsnippet

snippet puwillcallback "PHPUnit / Will return callback" i
->will(\$this->returnCallback(${1:function (${2}) {${3}})})
endsnippet

snippet puwillconsecutive "PHPUnit / Will conscutive calls" i
->will(\$this->onConsecutiveCalls(${1}))
endsnippet

snippet puwillexception "PHPUnit / Will throw exception" i
->will(\$this->throwException(new ${1:\Exception}))
endsnippet

snippet puwillself "PHPUnit / Will return self" i
->will(\$this->returnSelf())
endsnippet

snippet puwillmap "PHPUnit / Will return value map" i
->will(\$this->returnValueMap(${1}))
endsnippet

# :vim:ft=snippets:

